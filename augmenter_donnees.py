# import json
# import os
# import nlpaug.augmenter.word as naw
# import nltk
# nltk.download("wordnet")

# from utils import charger_donnees_json

# data_path = "data/Nestle-HR-FAQ.json"
# output_path = "data/Nestle-HR-FAQ-augmente.json"

# def augmenter_donnees():
#     questions, reponses = charger_donnees_json(data_path)

#     print("üîÅ G√©n√©ration des variantes synonymiques (x2)...")

#     aug = naw.SynonymAug(aug_src="wordnet")
#     nouvelles_qa = []

#     for q, r in zip(questions, reponses):
#         nouvelles_qa.append({"question": q, "response": r})
#         try:
#             for _ in range(2):  # 2 variantes par question
#                 q_aug = aug.augment(q)
#                 if q_aug and isinstance(q_aug, str) and q_aug != q:
#                     nouvelles_qa.append({"question": q_aug, "response": r})
#         except Exception as e:
#             print(f"Erreur sur : {q} ‚Üí {e}")

#     print(f"‚úÖ {len(nouvelles_qa)} entr√©es g√©n√©r√©es au total.")

#     data_struct = {"faq": {"donnees_augmentees": nouvelles_qa}}

#     os.makedirs("data", exist_ok=True)

#     with open(output_path, "w", encoding="utf-8") as f:
#         json.dump(data_struct, f, ensure_ascii=False, indent=2)

#     print(f"üíæ Fichier sauvegard√© ‚Üí {output_path}")

# if __name__ == "__main__":
#     augmenter_donnees()

"""
Augmenteur de donn√©es FAQ RH - G√©n√©ration de variantes synonymiques
Auteur: Syst√®me d'augmentation de donn√©es NLP
Description: G√©n√®re automatiquement des variantes de questions FAQ pour enrichir les donn√©es d'entra√Ænement
"""

import json
import os
import nltk
import nlpaug.augmenter.word as naw
from typing import Dict, List, Optional
from utils import charger_donnees_json
import sys
import io
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')

def telecharger_ressources_nltk():
    """
    T√©l√©charge les ressources NLTK n√©cessaires pour l'augmentation de donn√©es
    """
    print("üì¶ T√©l√©chargement des ressources NLTK...")
    
    ressources = [
        "wordnet",
        "averaged_perceptron_tagger", 
        "averaged_perceptron_tagger_eng",
        "punkt"
    ]
    
    for ressource in ressources:
        try:
            nltk.download(ressource, quiet=True)
            print(f"‚úÖ {ressource} t√©l√©charg√©")
        except Exception as e:
            print(f"‚ö†Ô∏è √âchec du t√©l√©chargement de {ressource}: {e}")
    
    print("üéØ Ressources NLTK pr√™tes!\n")


class FAQAugmenter:
    """
    Classe pour augmenter les donn√©es FAQ RH avec des variantes synonymiques
    
    Attributes:
        data_path (str): Chemin vers le fichier JSON source
        output_path (str): Chemin vers le fichier JSON de sortie
        augmenter: Instance de l'augmenteur de synonymes
    """
    
    def __init__(self, data_path: str, output_path: str):
        """
        Initialise l'augmenteur FAQ
        
        Args:
            data_path (str): Chemin vers le fichier JSON source
            output_path (str): Chemin vers le fichier JSON de sortie
        """
        self.data_path = data_path
        self.output_path = output_path
        self.augmenter = naw.SynonymAug(aug_src="wordnet")
        self.statistiques = {
            "questions_originales": 0,
            "variantes_generees": 0,
            "erreurs_generation": 0,
            "themes_traites": 0
        }
    
    def lire_donnees_source(self) -> Dict:
        """
        Lit le fichier JSON source avec gestion d'erreurs
        
        Returns:
            dict: Donn√©es FAQ charg√©es depuis le fichier JSON
            
        Raises:
            FileNotFoundError: Si le fichier source n'existe pas
            json.JSONDecodeError: Si le format JSON est invalide
        """
        print("üîÅ Lecture du fichier JSON original...")
        
        try:
            with open(self.data_path, "r", encoding="utf-8") as f:
                data = json.load(f)
            
            # Validation de la structure des donn√©es
            if "faq" not in data:
                raise ValueError("Structure JSON invalide : cl√© 'faq' manquante")
            
            print(f"‚úÖ Fichier lu avec succ√®s : {self.data_path}")
            print(f"üìä {len(data['faq'])} th√®mes d√©tect√©s")
            
            return data
            
        except FileNotFoundError:
            print(f"‚ùå Erreur : Fichier introuvable - {self.data_path}")
            raise
        except json.JSONDecodeError as e:
            print(f"‚ùå Erreur : Format JSON invalide - {self.data_path}")
            print(f"   D√©tail : {e}")
            raise
        except Exception as e:
            print(f"‚ùå Erreur inattendue lors de la lecture : {e}")
            raise
    
    def generer_variantes_question(self, question: str, nb_variantes: int = 2) -> List[str]:
        """
        G√©n√®re des variantes synonymiques d'une question
        
        Args:
            question (str): Question originale √† augmenter
            nb_variantes (int): Nombre de variantes √† g√©n√©rer (d√©faut: 2)
            
        Returns:
            List[str]: Liste des variantes g√©n√©r√©es (filtr√©es et uniques)
        """
        variantes = []
        
        if not question or not question.strip():
            print("‚ö†Ô∏è Question vide ou invalide d√©tect√©e")
            return variantes
        
        try:
            tentatives = 0
            max_tentatives = nb_variantes * 2  # Permet plus de tentatives
            
            while len(variantes) < nb_variantes and tentatives < max_tentatives:
                variante = self.augmenter.augment(question)
                
                # Validation de la variante
                if self._valider_variante(variante, question, variantes):
                    variantes.append(variante)
                
                tentatives += 1
                
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur pour '{question[:50]}...' ‚Üí {e}")
            self.statistiques["erreurs_generation"] += 1
        
        return variantes
    
    def _valider_variante(self, variante: str, question_originale: str, variantes_existantes: List[str]) -> bool:
        """
        Valide qu'une variante est acceptable
        
        Args:
            variante (str): Variante √† valider
            question_originale (str): Question originale
            variantes_existantes (List[str]): Variantes d√©j√† g√©n√©r√©es
            
        Returns:
            bool: True si la variante est valide
        """
        return (
            isinstance(variante, str) and
            variante.strip() and
            variante != question_originale and
            variante not in variantes_existantes and
            len(variante) > 10  # √âvite les variantes trop courtes
        )
    
    def augmenter_donnees_par_theme(self) -> Dict:
        """
        G√©n√®re des variantes synonymiques pour chaque question dans chaque th√®me RH
        
        Returns:
            dict: Donn√©es FAQ augment√©es avec les variantes
        """
        # Charger les donn√©es source
        data = self.lire_donnees_source()
        
        # Initialiser la structure des donn√©es augment√©es
        data_augmente = {"faq": {}}
        
        print("üß† G√©n√©ration des variantes par section RH...")
        print("=" * 50)
        
        # Parcourir chaque th√®me et ses questions
        for theme, items in data["faq"].items():
            print(f"üîπ Th√®me : {theme}")
            data_augmente["faq"][theme] = []
            
            questions_theme = 0
            
            for item in items:
                question = item.get("question", "")
                reponse = item.get("response", "")
                
                if not question:
                    print(f"‚ö†Ô∏è Question vide d√©tect√©e dans le th√®me {theme}")
                    continue
                
                # Ajouter la question originale
                data_augmente["faq"][theme].append({
                    "question": question,
                    "response": reponse
                })
                questions_theme += 1
                self.statistiques["questions_originales"] += 1
                
                # G√©n√©rer et ajouter les variantes
                variantes = self.generer_variantes_question(question, nb_variantes=2)
                
                for variante in variantes:
                    data_augmente["faq"][theme].append({
                        "question": variante,
                        "response": reponse
                    })
                    questions_theme += 1
                    self.statistiques["variantes_generees"] += 1
            
            print(f"   ‚úÖ {questions_theme} questions g√©n√©r√©es pour ce th√®me")
            self.statistiques["themes_traites"] += 1
        
        print("=" * 50)
        total_questions = sum(len(items) for items in data_augmente["faq"].values())
        print(f"üéØ {total_questions} questions g√©n√©r√©es au total")
        
        return data_augmente
    
    def sauvegarder_donnees(self, data_augmente: Dict):
        """
        Sauvegarde les donn√©es augment√©es dans un fichier JSON
        
        Args:
            data_augmente (dict): Donn√©es FAQ augment√©es
            
        Raises:
            Exception: Si la sauvegarde √©choue
        """
        print("üíæ Sauvegarde des donn√©es augment√©es...")
        
        # Cr√©er le r√©pertoire de sortie si n√©cessaire
        repertoire_sortie = os.path.dirname(self.output_path)
        if repertoire_sortie:
            os.makedirs(repertoire_sortie, exist_ok=True)
        
        try:
            with open(self.output_path, "w", encoding="utf-8") as f:
                json.dump(data_augmente, f, indent=2, ensure_ascii=False)
            
            # V√©rifier la taille du fichier
            taille_fichier = os.path.getsize(self.output_path) / 1024  # en KB
            print(f"‚úÖ Fichier sauvegard√© : {self.output_path}")
            print(f"üìè Taille du fichier : {taille_fichier:.1f} KB")
            
        except Exception as e:
            print(f"‚ùå Erreur lors de la sauvegarde : {e}")
            raise
    
    def afficher_statistiques(self):
        """
        Affiche les statistiques d√©taill√©es de l'augmentation
        """
        print("\n" + "="*60)
        print("üìä STATISTIQUES D√âTAILL√âES")
        print("="*60)
        print(f"üîπ Questions originales    : {self.statistiques['questions_originales']}")
        print(f"üîπ Variantes g√©n√©r√©es      : {self.statistiques['variantes_generees']}")
        print(f"üîπ Total questions         : {self.statistiques['questions_originales'] + self.statistiques['variantes_generees']}")
        print(f"üîπ Th√®mes trait√©s          : {self.statistiques['themes_traites']}")
        print(f"üîπ Erreurs de g√©n√©ration   : {self.statistiques['erreurs_generation']}")
        
        if self.statistiques['questions_originales'] > 0:
            taux_augmentation = (self.statistiques['variantes_generees'] / 
                               self.statistiques['questions_originales']) * 100
            print(f"üîπ Taux d'augmentation     : {taux_augmentation:.1f}%")
        
        print("="*60)
    
    def executer_augmentation(self):
        """
        Ex√©cute le processus complet d'augmentation des donn√©es FAQ
        """
        print("üöÄ D√©marrage de l'augmentation des donn√©es FAQ RH...")
        print("="*60)
        
        try:
            # √âtape 1: G√©n√©rer les donn√©es augment√©es
            data_augmente = self.augmenter_donnees_par_theme()
            
            # √âtape 2: Sauvegarder les r√©sultats
            self.sauvegarder_donnees(data_augmente)
            
            # √âtape 3: Afficher les statistiques
            self.afficher_statistiques()
            
            print(f"\nüéØ PROCESSUS TERMIN√â AVEC SUCC√àS!")
            print(f"üìÑ Fichier de sortie : {self.output_path}")
            
        except Exception as e:
            print(f"‚ùå √âchec de l'augmentation : {e}")
            print("üîß V√©rifiez les chemins de fichiers et les permissions")
            raise


def main():
    """
    Fonction principale pour ex√©cuter l'augmentation des donn√©es FAQ
    """
    # Configuration des chemins
    data_path = "data/Nestle-HR-FAQ.json"
    output_path = "data/Nestle-HR-FAQ-augmente.json"
    
    # T√©l√©charger les ressources NLTK
    telecharger_ressources_nltk()
    
    # Cr√©er et ex√©cuter l'augmenteur
    try:
        augmenteur = FAQAugmenter(data_path, output_path)
        augmenteur.executer_augmentation()
        
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è Processus interrompu par l'utilisateur")
    except Exception as e:
        print(f"\n‚ùå Erreur critique : {e}")
        print("üîß V√©rifiez votre configuration et r√©essayez")


if __name__ == "__main__":
    main()